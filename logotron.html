<!DOCTYPE html>
<meta charset="utf-8">
<title>Logotron!</title>
<link rel="stylesheet" href="tipsy.css">
<script src="jquery.min.js"></script>
<script src="jquery.tipsy.js"></script>
<script>
var Logo = {
  WHITESPACE: /[ \r\n\t]/,
  LITERALS: /[ \[\]]/,
  tokenize: function Logo_tokenize(str) {
    var tokens = [];
    var state = 'whitespace';
    var stateStartI = 0;
    var i;
    var letter;

    var stateMethods = {
      whitespace: function() {
        if (Logo.WHITESPACE.test(letter))
          return;
        if (Logo.LITERALS.test(letter))
          return setState('characterSymbol');
        if (letter == ';')
          return setState('comment');
        setState('word');
      },
      word: function() {
        if (Logo.WHITESPACE.test(letter))
          return setState('whitespace');
        if (Logo.LITERALS.test(letter))
          return setState('characterSymbol');
        if (letter == ';')
          return setState('comment');
      },
      comment: function() {
        if (letter == '\n')
          setState('whitespace');
      },
      characterSymbol: function() {
        setState('whitespace');
        this.whitespace();
      }
    };

    function setState(name) {
      if (state != name) {
        if (i > stateStartI)
          tokens.push({
            id: tokens.length,
            name: state,
            value: str.slice(stateStartI, i),
            start: stateStartI,
            end: i,
            messages: [],
            tags: []
          });
        state = name;
        stateStartI = i;
      }
    }

    for (i = 0; i < str.length; i++) {
      letter = str[i];      
      stateMethods[state]();
    }

    setState(null);
    
    return tokens;
  },
  parse: function Logo_parse(tokens) {
    function stripWhitespaceAndComments(tokens) {
      var newTokens = [];
      tokens.forEach(function(token) {
        if (token.name != 'whitespace' && token.name != 'comment')
          newTokens.push(token);
      });
      
      newTokens.push({
        name: 'end-of-file',
        value: null,
        tags: []
      });

      return newTokens;
    }

    function parse(tokens) {
      var vocabulary = {
        fd: {
          args: [":amount"]
        },
        rt: {
          args: [":amount"]
        }
      };
      var keywords = {
        repeat: function() {
          var repeat = {
            times: null,
            start: token,
            statements: []
          };
          token.tags.push("control-structure");
          advance();
          if (token.name == "word") {
            repeat.times = token;
            advance();
            if (token.name == "characterSymbol" &&
                token.value == "[") {
              advance();
              while (!(token.name == "characterSymbol" &&
                       token.value == "]") &&
                     !(token.name == "end-of-file")) {
                var statement = processStatement();
                if (!statement)
                  break;
                repeat.statements.push(statement);
                advance();
              }
              if (!(token.name == "characterSymbol" &&
                    token.value == "]"))
                error({type: "end-not-found",
                       fallback: repeat.start,
                       message: "I couldn't find the end of the " +
                                "repeat block."});
            } else
              error({type: "unexpected-token",
                     message: "I expected a [ here."});
          } else
            error({type: "unexpected-token",
                   message: "I expected a word indicating " +
                            "the number of times to repeat here."});
          return repeat;
        },
        to: function() {
          var defn = {
            type: 'definition',
            start: token,
            word: null,
            args: [],
            statements: []
          };
          token.tags.push("definition");
          advance();
          if (token.name == "word") {
            token.tags.push("defined-word");
            defn.word = token;
            // TODO: Ensure there's no namespace conflicts.
            advance();
            while (token.name == "word" &&
                   token.value[0] == ":") {
              token.tags.push("argument-name");
              defn.args.push(token);
              advance();
            }
            while (!(token.name == "word" && token.value == "end") &&
                   !(token.name == "end-of-file")) {
              var statement = processStatement();
              if (!statement)
                break;
              defn.statements.push(statement);
              advance();
            }
            if (!(token.name == "word" && token.value == "end"))
              error({type: "end-not-found",
                     fallback: defn.start,
                     message: "I couldn't find the end of this " +
                              "definition."});
          } else
            error({type: "unexpected-token",
                   message: "I was expecting the name of a new word " +
                            "to define."});
          return defn;
        }
      };
      var i = 0;
      var token = tokens[i];
      var errorsFound = false;

      function advance() {
        i++;
        if (i < tokens.length)
          token = tokens[i];
      }

      function error(options) {
        if (!errorsFound) {
          errorsFound = true;
          var errorToken = token;
          if (token.name == 'end-of-file' && options.fallback)
            errorToken = options.fallback;
          errorToken.messages.push(options.message);
          errorToken.tags.push("fatal");
          errorToken.tags.push(options.type);
        }
      }

      function processStatement() {
        var statement = null;
        
        if (token.name == 'end-of-file')
          return statement;
        
        if (token.name == 'word') {
          if (token.value in keywords) {
            statement = keywords[token.value]();
          } else if (token.value in vocabulary) {
            statement = {
              name: token.value,
              type: 'call',
              start: token,
              args: []
            };
            token.tags.push("function-call");
            vocabulary[token.value].args.forEach(function(arg) {
              if (errorsFound)
                return;
              advance();
              if (token.name == "word") {
                token.tags.push("argument");
                statement.args.push(token);
              } else
                error({type: "unexpected-token",
                       fallback: statement.start,
                       message: "I was expecting a value for " +
                                arg + " for " + statement.name + "."});
            });
          } else
            error({type: "unknown-name",
                   message: "I have no idea what this word means."});
        } else
          error({type: "unexpected-token",
                 message: "I was expecting a word, but got this instead."});
        return statement;
      }

      function processStatementList() {
        var statements = [];
        while (i < tokens.length) {
          var statement = processStatement();
          if (!statement)
            return statements;
          statements.push(statement);
          advance();
        }
        return statements;
      }

      var program = processStatementList();
      while (i < tokens.length) {
        token.tags.push("unparsed");
        advance();
      }
      return {
        program: program,
        errorsFound: errorsFound
      };
    }

    return parse(stripWhitespaceAndComments(tokens));
  }
};

$(window).ready(function() {
  var lastCodeValue;

  $("#raw-code").hide();
  $("#rendered-code").show();
  $("#rendered-code").click(function() {
    $(this).hide();
    $("#raw-code").show();
    $("#raw-code").focus();
  });
  
  $("#raw-code").blur(function() {
    var currVal = $(this).val();
    if (currVal != lastCodeValue) {
      lastCodeValue = currVal;
      var tokens = Logo.tokenize(lastCodeValue);
      $("#rendered-code").empty();
      tokens.forEach(function(token) {
        var span = $('<span class="token"></span>');
        span.addClass(token.name);
        span.text(token.value);
        token.query = span;
        $("#rendered-code").append(span);
      });
      var program = Logo.parse(tokens);
      tokens.forEach(function(token) {
        if (token.tags.length)
          token.query.addClass(token.tags.join(" "));
        if (token.messages.length) {
          var message = token.messages.join(" ");
          token.query.attr("title", message);
          token.query.tipsy({gravity: 'nw'});
        }
      });
    }
    $(this).hide();
    $("#rendered-code").show();
  });
});
</script>
<style>
#rendered-code span {
  white-space: pre-wrap;
}

.token.comment {
  color: firebrick;
}

.token.characterSymbol {
  color: gray;
}

.token.broken {
  text-decoration: line-through;
}

.token.unparsed {
  color: #c0c0c0;
}

.token.fatal {
  color: red;
}

.token.defined-word {
  font-weight: bold;
}

.token.argument-name {
  font-style: italic;
}

.code {
  width: 40em;
  height: 40em;
  outline: none;
  font-family: Monaco, monospace;
  font-size: 10pt;
  border: 1px dotted gray;
  padding: 1em;
}
</style>
<textarea id="raw-code" class="code"></textarea>
<div id="rendered-code" class="code"></div>
