<!DOCTYPE html>
<meta charset="utf-8">
<title>Logotron!</title>
<link rel="stylesheet" href="tipsy.css">
<script src="jquery.min.js"></script>
<script src="jquery.tipsy.js"></script>
<script>
var Logo = {
  WHITESPACE: /[ \r\n\t]/,
  LITERALS: /[ \[\]]/,
  tokenize: function Logo_tokenize(str) {
    var tokens = [];
    var state = 'whitespace';
    var stateStartI = 0;
    var i;
    var letter;

    var stateMethods = {
      whitespace: function() {
        if (Logo.WHITESPACE.test(letter))
          return;
        if (Logo.LITERALS.test(letter))
          return setState('characterSymbol');
        if (letter == ';')
          return setState('comment');
        setState('word');
      },
      word: function() {
        if (Logo.WHITESPACE.test(letter))
          return setState('whitespace');
        if (Logo.LITERALS.test(letter))
          return setState('characterSymbol');
        if (letter == ';')
          return setState('comment');
      },
      comment: function() {
        if (letter == '\n')
          setState('whitespace');
      },
      characterSymbol: function() {
        setState('whitespace');
        this.whitespace();
      }
    };

    function setState(name) {
      if (state != name) {
        if (i > stateStartI)
          tokens.push({
            id: tokens.length,
            name: state,
            value: str.slice(stateStartI, i),
            start: stateStartI,
            end: i,
            messages: [],
            query: null
          });
        state = name;
        stateStartI = i;
      }
    }

    for (i = 0; i < str.length; i++) {
      letter = str[i];      
      stateMethods[state]();
    }

    setState(null);
    
    return tokens;
  },
  parse: function Logo_parse(tokens) {
    function stripWhitespaceAndComments(tokens) {
      var newTokens = [];
      tokens.forEach(function(token) {
        if (token.name != 'whitespace' && token.name != 'comment')
          newTokens.push(token);
      });
      
      newTokens.push({
        name: 'end-of-file',
        value: null,
        query: $()
      });

      return newTokens;
    }

    function parse(tokens) {
      var vocabulary = {
        fd: {
          args: [":amount"]
        },
        rt: {
          args: [":amount"]
        }
      };
      var keywords = {
        to: function() {
          var defn = {
            type: 'definition',
            start: token,
            word: null,
            args: [],
            statements: []
          };
          token.query.addClass("definition");
          advance();
          if (token.name == "word") {
            token.query.addClass("defined-word");
            defn.word = token;
            // TODO: Ensure there's no namespace conflicts.
            advance();
            while (token.name == "word" &&
                   token.value[0] == ":") {
              token.query.addClass("argument-name");
              defn.args.push(token);
              advance();
            }
            while (!(token.name == "word" && token.value == "end") &&
                   !(token.name == "end-of-file")) {
              var statement = processStatement();
              if (!statement)
                break;
              defn.statements.push(statement);
              advance();
            }
            if (!(token.name == "word" && token.value == "end")) {
              defn.start.query.addClass("broken");
              defn.start.messages.push("I couldn't find the end of " +
                                       "this definition.");
            }
          } else
            token.query.addClass("fatal unexpected-token");
          return defn;
        }
      };
      var i = 0;
      var token = tokens[i];

      function advance() {
        token = tokens[++i];
      }

      function processStatement() {
        var statement = null;
        
        if (token.name == 'end-of-file')
          return statement;
        
        if (token.name == 'word') {
          if (token.value in keywords) {
            statement = keywords[token.value]();
          } else if (token.value in vocabulary) {
            statement = {
              name: token.value,
              type: 'call',
              start: token,
              args: []
            };
            token.query.addClass("function-call");
            vocabulary[token.value].args.forEach(function(arg) {
              if (statement.start.query.hasClass("broken"))
                return;
              advance();
              if (token.name == "word") {
                token.query.addClass("argument");
                statement.args.push(token);
              } else {
                statement.start.query.addClass("broken");
                token.query.addClass("fatal unexpected-token");
              }
            });
          } else
            token.query.addClass("fatal unknown-name");
        } else
          token.query.addClass("fatal unexpected-token");
        return statement;
      }

      function processStatementList() {
        var statements = [];
        while (i < tokens.length) {
          var statement = processStatement();
          if (!statement)
            return statements;
          statements.push(statement);
          advance();
        }
        return statements;
      }

      var program = processStatementList();
      while (i < tokens.length) {
        token.query.addClass("unparsed");
        advance();
      }
      return program;
    }

    return parse(stripWhitespaceAndComments(tokens));
  }
};

$(window).ready(function() {
  var lastCodeValue;

  $("#raw-code").hide();
  $("#rendered-code").show();
  $("#rendered-code").click(function() {
    $(this).hide();
    $("#raw-code").show();
    $("#raw-code").focus();
  });
  
  $("#raw-code").blur(function() {
    var currVal = $(this).val();
    if (currVal != lastCodeValue) {
      lastCodeValue = currVal;
      var tokens = Logo.tokenize(lastCodeValue);
      $("#rendered-code").empty();
      tokens.forEach(function(token) {
        var span = $('<span class="token"></span>');
        span.addClass(token.name);
        span.text(token.value);
        token.query = span;
        $("#rendered-code").append(span);
      });
      var program = Logo.parse(tokens);
      tokens.forEach(function(token) {
        if (token.messages.length) {
          var message = token.messages.join(" ");
          token.query.attr("title", message);
          token.query.tipsy({gravity: 'nw'});
        }
      });
    }
    $(this).hide();
    $("#rendered-code").show();
  });
});
</script>
<style>
#rendered-code span {
  white-space: pre-wrap;
}

.token.comment {
  color: firebrick;
}

.token.characterSymbol {
  color: gray;
}

.token.broken {
  text-decoration: line-through;
}

.token.unparsed {
  color: #c0c0c0;
}

.token.fatal {
  color: red;
}

.token.defined-word {
  font-weight: bold;
}

.token.argument-name {
  font-style: italic;
}

.code {
  width: 40em;
  height: 40em;
  outline: none;
  font-family: Monaco, monospace;
  font-size: 10pt;
  border: 1px dotted gray;
  padding: 1em;
}
</style>
<textarea id="raw-code" class="code"></textarea>
<div id="rendered-code" class="code"></div>
